# Архитектурная диаграмма: Последовательная vs Параллельная обработка

## 🔴 Текущая архитектура (последовательная)

```
┌─────────────────────────────────────────────────────────────┐
│                        Main Process                          │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Batch [10 entries]                      │  │
│  └──────────────────────────────────────────────────────┘  │
│                           │                                  │
│                           ▼                                  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Entry 1  ──► validate_entry() ──► LLM API (3s)     │  │
│  └──────────────────────────────────────────────────────┘  │
│                           │                                  │
│                           ▼                                  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Entry 2  ──► validate_entry() ──► LLM API (3s)     │  │
│  └──────────────────────────────────────────────────────┘  │
│                           │                                  │
│                           ▼                                  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Entry 3  ──► validate_entry() ──► LLM API (3s)     │  │
│  └──────────────────────────────────────────────────────┘  │
│                           │                                  │
│                          ...                                 │
│                           │                                  │
│                           ▼                                  │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  Entry 10 ──► validate_entry() ──► LLM API (3s)     │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  Total time: 10 × 3s = 30 seconds                           │
└─────────────────────────────────────────────────────────────┘
```

### Характеристики:
- ⏱️ **Время обработки батча:** 30 секунд (для 10 записей)
- 🐌 **Пропускная способность:** 0.33 записи/сек
- ⚠️ **Узкое место:** Ожидание ответа от API
- 💻 **Использование CPU:** < 5%
- 🌐 **Использование сети:** < 10%

---

## 🟢 Предлагаемая архитектура (параллельная)

```
┌─────────────────────────────────────────────────────────────────────┐
│                          Main Process                                │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                  Batch [10 entries]                        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                 │                                    │
│                                 ▼                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │            ThreadPoolExecutor (5 workers)                  │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                 │                                    │
│         ┌───────────────────────┼───────────────────────┐          │
│         ▼                       ▼                       ▼          │
│  ┌──────────┐           ┌──────────┐           ┌──────────┐       │
│  │ Thread 1 │           │ Thread 2 │           │ Thread 3 │       │
│  ├──────────┤           ├──────────┤           ├──────────┤       │
│  │ Entry 1  │           │ Entry 2  │           │ Entry 3  │       │
│  │    ↓     │           │    ↓     │           │    ↓     │       │
│  │validate_ │           │validate_ │           │validate_ │       │
│  │ entry()  │           │ entry()  │           │ entry()  │       │
│  │    ↓     │           │    ↓     │           │    ↓     │       │
│  │ LLM API  │           │ LLM API  │           │ LLM API  │       │
│  │  (3s)    │           │  (3s)    │           │  (3s)    │       │
│  └──────────┘           └──────────┘           └──────────┘       │
│         │                       │                       │          │
│         ▼                       ▼                       ▼          │
│  ┌──────────┐           ┌──────────┐           ┌──────────┐       │
│  │ Thread 4 │           │ Thread 5 │           │          │       │
│  ├──────────┤           ├──────────┤           │ (waiting)│       │
│  │ Entry 4  │           │ Entry 5  │           │          │       │
│  │    ↓     │           │    ↓     │           │          │       │
│  │validate_ │           │validate_ │           │          │       │
│  │ entry()  │           │ entry()  │           │          │       │
│  │    ↓     │           │    ↓     │           │          │       │
│  │ LLM API  │           │ LLM API  │           │          │       │
│  │  (3s)    │           │  (3s)    │           │          │       │
│  └──────────┘           └──────────┘           └──────────┘       │
│         │                       │                                    │
│         └───────────┬───────────┘                                    │
│                     ▼                                                │
│            (После завершения первых 5)                              │
│                     │                                                │
│         ┌───────────┼───────────┐                                   │
│         ▼           ▼           ▼                                   │
│   Entry 6     Entry 7     Entry 8                                   │
│      ...         ...         ...                                    │
│                                                                      │
│  Total time: ceil(10 / 5) × 3s = 6 seconds                         │
└─────────────────────────────────────────────────────────────────────┘
```

### Характеристики:
- ⚡ **Время обработки батча:** 6 секунд (для 10 записей)
- 🚀 **Пропускная способность:** 1.67 записи/сек
- ✅ **Прирост:** **5x** по сравнению с последовательной
- 💻 **Использование CPU:** ~10-15%
- 🌐 **Использование сети:** ~40-50%

---

## 🔄 Взаимодействие компонентов

```
┌─────────────────────────────────────────────────────────────────┐
│                           main.py                                │
│                                                                  │
│  for batch in batches:                                          │
│    ┌──────────────────────────────────────────────────────┐    │
│    │  validate_batch_parallel(entries, max_workers=5)     │    │
│    │                      ↓                                │    │
│    │         parallel.py (новый модуль)                   │    │
│    └──────────────────────────────────────────────────────┘    │
│                          ↓                                       │
│         ┌────────────────┴────────────────┐                     │
│         ▼                                  ▼                     │
│  ┌──────────────┐                  ┌──────────────┐            │
│  │ pipeline.py  │                  │ llm_client.py│            │
│  │ validate_    │ ─────────────►   │ generate()   │            │
│  │ entry()      │                  │              │            │
│  └──────────────┘                  └──────────────┘            │
│         ↓                                  ↓                     │
│  ┌──────────────┐                  ┌──────────────┐            │
│  │  cache.py    │                  │  OpenAI API  │            │
│  │  (thread-    │                  │  (external)  │            │
│  │   safe)      │                  │              │            │
│  └──────────────┘                  └──────────────┘            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🔐 Thread-Safety: SQLite Cache

### Проблема (текущая версия):

```
Thread 1: cache.get_payload()  ──┐
                                  ├──► SQLite Connection
Thread 2: cache.store_payload() ──┘     (NOT THREAD-SAFE!)
                                         ⚠️ Race condition
```

### Решение (с Lock):

```
Thread 1: cache.get_payload()  ──┐
                                  │     ┌──────────────┐
                                  ├──►  │ Lock.acquire │
Thread 2: cache.store_payload() ──┘    │      ↓       │
          (waits...)                    │   SQLite     │
                                        │      ↓       │
                                        │ Lock.release │
                                        └──────────────┘
                                        ✅ Thread-safe!
```

**Код:**
```python
class CacheStore:
    def __init__(self, path: Path):
        self._lock = threading.Lock()  # НОВОЕ
        self._conn = sqlite3.connect(str(path), check_same_thread=False)
    
    def get_payload(self, ...):
        with self._lock:  # Защита
            cursor = self._conn.execute(...)
            return cursor.fetchone()
```

---

## 📊 Обработка Rate Limiting

### Без обработки ошибок:

```
Thread 1: Request → 200 OK ✓
Thread 2: Request → 200 OK ✓
Thread 3: Request → 200 OK ✓
Thread 4: Request → 200 OK ✓
Thread 5: Request → 429 Rate Limit ❌ → Crash!
```

### С exponential backoff:

```
Thread 1: Request → 200 OK ✓
Thread 2: Request → 200 OK ✓
Thread 3: Request → 200 OK ✓
Thread 4: Request → 200 OK ✓
Thread 5: Request → 429 Rate Limit
           ↓
         Retry after 1s
           ↓
         Request → 200 OK ✓
```

**Алгоритм:**
```python
for attempt in range(max_retries):
    try:
        return validate_entry(...)
    except RateLimitError:
        delay = base_delay * (2 ** attempt)  # 1s, 2s, 4s, ...
        time.sleep(delay)
        continue
```

---

## 🎯 Оптимальное количество потоков

### Зависимость от API tier:

```
                   Throughput
                      ▲
                      │
   Tier 2+ (RPM:3500+)│        ╭─────────────
                      │      ╭─╯
   Tier 1 (RPM:500)   │   ╭──╯
                      │ ╭─╯
   Free (RPM:20)      │╯
                      │
                      └─────────────────────────►
                        1   3   5   7   10   15
                            Workers (threads)

   ⚠️ Rate limits            ✓ Optimal
```

**Рекомендации:**
- **Free tier:** 1-2 потока
- **Tier 1:** 3-5 потоков ⭐ (оптимально для большинства)
- **Tier 2+:** 5-10 потоков

---

## 💰 Влияние на prompt caching

### Последовательная обработка:

```
Request 1: [Rules: 5000 tokens] + [Data: 100 tokens] → 5100 tokens
           ↓ (cache created)
Request 2: [Rules: 5000 tokens] + [Data: 100 tokens] → 5100 tokens
           ↓ (cache hit: -2500 tokens saved, 50%)
Request 3: [Rules: 5000 tokens] + [Data: 100 tokens] → 5100 tokens
           ↓ (cache hit: -2500 tokens saved, 50%)
           
Cache hit rate: ~100% (after first request)
Cost savings: ~50%
```

### Параллельная обработка (5 потоков):

```
Time 0:
  Thread 1: Request 1 → cache created
  Thread 2: Request 2 → cache NOT YET created
  Thread 3: Request 3 → cache NOT YET created
  Thread 4: Request 4 → cache NOT YET created
  Thread 5: Request 5 → cache NOT YET created

Time 1s:
  Thread 1: Response received → cache READY
  Thread 2: Request 6 → cache hit! ✓
  Thread 3: Request 7 → cache hit! ✓
  Thread 4: Request 8 → cache hit! ✓
  Thread 5: Request 9 → cache hit! ✓

Cache hit rate: ~50% (first 5 miss, rest hit)
Cost savings: ~25% overall
```

**Вывод:** Prompt caching работает, но менее эффективно при высоком параллелизме.

**Оптимизация:**
- Использовать `batch_size: 10` для обработки групп
- Использовать `max_workers: 5` (не слишком много)
- Первые N запросов будут дороже, остальные дешевле

---

## 📈 Сравнение метрик

| Метрика                | Последовательно | Параллельно (5) | Улучшение |
|------------------------|-----------------|-----------------|-----------|
| Время на 10 записей   | 30 сек          | 6 сек           | **5x**    |
| Время на 100 записей  | 300 сек         | 60 сек          | **5x**    |
| Entries/sec           | 0.33            | 1.67            | **5x**    |
| CPU usage             | ~5%             | ~15%            | +10%      |
| Network usage         | ~10%            | ~50%            | +40%      |
| Prompt cache hit rate | ~95%            | ~85%            | -10%      |
| Overall cost          | 100%            | ~110%           | +10%      |

**Вывод:** 
- ✅ **Время:** снижается в 5 раз
- ⚠️ **Стоимость:** незначительно увеличивается (+10%) из-за меньшего hit rate кеша
- ✅ **ROI:** Экономия времени перевешивает небольшое увеличение стоимости

---

## 🛠️ Техническая реализация

### Стек технологий:

```
┌──────────────────────────────────────────┐
│        concurrent.futures                │  ← High-level API
├──────────────────────────────────────────┤
│        ThreadPoolExecutor                │  ← Thread pool
├──────────────────────────────────────────┤
│        threading.Thread                  │  ← OS threads
├──────────────────────────────────────────┤
│        threading.Lock                    │  ← Synchronization
├──────────────────────────────────────────┤
│        sqlite3 (check_same_thread=False) │  ← Thread-safe DB
└──────────────────────────────────────────┘
```

### Альтернативы (не используем):

```
❌ asyncio + aiohttp
   └─ Требует переписывания всего LLM клиента
   └─ Трудозатраты: 3-5 дней
   └─ Прирост: +10-20% к ThreadPoolExecutor

❌ multiprocessing
   └─ Избыточная сложность для I/O-bound
   └─ Проблемы с pickle для передачи объектов
   └─ Не даёт преимуществ перед ThreadPoolExecutor

✅ ThreadPoolExecutor
   └─ Идеально для I/O-bound операций
   └─ Минимальные изменения кода
   └─ GIL не проблема (ждём I/O, не CPU)
```

---

## 🎓 Итоговые рекомендации

1. ✅ **Использовать ThreadPoolExecutor** с 5 потоками
2. ✅ **Добавить threading.Lock** в CacheStore
3. ✅ **Реализовать exponential backoff** для rate limiting
4. ✅ **Мониторить метрики** (throughput, errors, costs)
5. ✅ **Начать с консервативных настроек** и постепенно увеличивать

**Ожидаемый результат:**
- 🚀 Производительность: **5x**
- 💰 Стоимость: **+10%**
- ⏱️ Время разработки: **5-10 часов**
- 🎯 ROI: **Отличный**

---

*Эта диаграмма является частью исследования многопоточности для проекта StatusValidator.*

